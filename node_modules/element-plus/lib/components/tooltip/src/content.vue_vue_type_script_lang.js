'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vue = require('vue');
var core = require('@vueuse/core');
require('../../popper/index.js');
require('../../visual-hidden/index.js');
var dom = require('../../../utils/dom.js');
require('../../../hooks/index.js');
var tooltip = require('./tooltip.js');
var tokens = require('./tokens.js');
var content_vue_vue_type_script_lang = require('../../popper/src/content.vue_vue_type_script_lang.js');
var visualHidden_vue_vue_type_script_lang = require('../../visual-hidden/src/visual-hidden.vue_vue_type_script_lang.js');
var index = require('../../../hooks/use-escape-keydown/index.js');

var script = vue.defineComponent({
  name: "ElTooltipContent",
  components: {
    ElPopperContent: content_vue_vue_type_script_lang["default"],
    ElVisuallyHidden: visualHidden_vue_vue_type_script_lang["default"]
  },
  inheritAttrs: false,
  props: tooltip.useTooltipContentProps,
  setup(props) {
    const contentRef = vue.ref(null);
    const intermediateOpen = vue.ref(false);
    const entering = vue.ref(false);
    const leaving = vue.ref(false);
    const { controlled, id, open, trigger, onClose, onOpen, onShow, onHide } = vue.inject(tokens.TOOLTIP_INJECTION_KEY, void 0);
    const persistentRef = vue.computed(() => {
      if (process.env.NODE_ENV === "test") {
        return true;
      }
      return props.persistent;
    });
    const shouldRender = vue.computed(() => {
      return vue.unref(persistentRef) ? true : vue.unref(open);
    });
    const shouldShow = vue.computed(() => {
      return props.disabled ? false : vue.unref(open);
    });
    const contentStyle = vue.computed(() => {
      var _a;
      return (_a = props.style) != null ? _a : {};
    });
    const ariaHidden = vue.computed(() => !vue.unref(open));
    index.useEscapeKeydown(onClose);
    const onTransitionLeave = () => {
      onHide();
    };
    const stopWhenControlled = () => {
      if (vue.unref(controlled))
        return true;
    };
    const onContentEnter = dom.composeEventHandlers(stopWhenControlled, () => {
      if (props.enterable && vue.unref(trigger) === "hover") {
        onOpen();
      }
    });
    const onContentLeave = dom.composeEventHandlers(stopWhenControlled, () => {
      if (vue.unref(trigger) === "hover") {
        onClose();
      }
    });
    const onBeforeEnter = () => {
      var _a, _b;
      (_b = (_a = contentRef.value) == null ? void 0 : _a.updatePopper) == null ? void 0 : _b.call(_a);
    };
    const onAfterShow = () => {
      onShow();
    };
    let stopHandle;
    vue.watch(() => vue.unref(open), (val) => {
      if (val) {
        stopHandle = core.onClickOutside(vue.computed(() => {
          var _a;
          return (_a = contentRef.value) == null ? void 0 : _a.popperContentRef;
        }), () => {
          if (vue.unref(controlled))
            return;
          const $trigger = vue.unref(trigger);
          if ($trigger !== "hover") {
            onClose();
          }
        });
      } else {
        stopHandle == null ? void 0 : stopHandle();
      }
    }, {
      flush: "post"
    });
    return {
      ariaHidden,
      entering,
      leaving,
      id,
      intermediateOpen,
      contentStyle,
      contentRef,
      shouldRender,
      shouldShow,
      open,
      onAfterShow,
      onBeforeEnter,
      onContentEnter,
      onContentLeave,
      onTransitionLeave
    };
  }
});

exports["default"] = script;
//# sourceMappingURL=content.vue_vue_type_script_lang.js.map
